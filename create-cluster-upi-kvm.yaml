- name: Create clusters UPI on KVM
  hosts: localhost
  become_method: sudo

  tasks:
    - name: Get a list of all virtual machines
      ansible.builtin.command: virsh list --all --name
      register: vms
      changed_when: vms.rc == 0
      become: true
      when: destroy_if_exists == "true"

    - name: Filter VMs containing 'clustername' in their names
      ansible.builtin.set_fact:
        allvms: "{{ vms.stdout_lines | select('search', clustername) }}"
      when: destroy_if_exists == "true"

    - name: Destroy all vms
      community.libvirt.virt:
        command: destroy
        force: true
        name: "{{ item }}"
      loop: "{{ allvms }}"
      ignore_errors: true
      become: true
      when: destroy_if_exists == "true"

    - name: Undefine all vms
      community.libvirt.virt:
        command: undefine
        force: true
        name: "{{ item }}"
      loop: "{{ allvms }}"
      ignore_errors: true
      become: true
      when: destroy_if_exists == "true"

    - name: Delete all network files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      register: deletefiles
      with_items:
        - "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        - "/etc/dnsmasq.{{ clustername }}.addnhosts"
        - "/{{ clusters_dir }}/{{ clustername }}/"
      become: true
      when: destroy_if_exists == "true"

    - name: Configuring networkmanager to use dnsmasq
      ansible.builtin.copy:
        dest: "/etc/NetworkManager/conf.d/nm-dns.conf"
        content: |
          [main]
          dns=dnsmasq
      register: configdnsmasq
      become: true

    - name: Stop systemd-resolved service
      ansible.builtin.systemd:
        name: systemd-resolved
        state: stopped
        enabled: false
      become: true
      when: ansible_facts['distribution'] == 'Fedora'

    - name: Disable systemd-resolved from starting at boot
      ansible.builtin.systemd:
        name: systemd-resolved
        enabled: false
      become: true
      when: ansible_facts['distribution'] == 'Fedora'

    - name: Remove /etc/resolv.conf
      ansible.builtin.file:
        path: /etc/resolv.conf
        state: absent
      when: ansible_facts['distribution'] == 'Fedora'
      become: true

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      become: true

    - name: Sleeping 5 seconds to wait NetworkManager
      ansible.builtin.pause:
        seconds: 5

    - name: Ensure necessary packages are installed
      ansible.builtin.yum:
        name:
          - qemu-kvm
          - libvirt
          - virt-install
          - virt-manager
          - guestfs-tools
          - python3-pip
          - coreos-installer
        state: present
      become: true

    - name: Ensure 'kubernetes' Python package is installed
      ansible.builtin.pip:
        name: kubernetes
        state: present
        executable: pip

    - name: Ensure libvirtd service is running
      ansible.builtin.service:
        name: libvirtd
        state: started
        enabled: true
      become: true

    - name: Create the OCP version cache directory if it does not exist
      ansible.builtin.file:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/"
        state: directory
        mode: '0755'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true

    - name: Check if the installer file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
      register: installfile

    - name: Download installer openshift-install-linux.tar.gz to cache
      ansible.builtin.get_url:
        url: "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/{{ ocpversion }}/openshift-install-linux.tar.gz"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        mode: '0644'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true
      when: installfile.stat is defined and not installfile.stat.exists

    - name: Check if rhcos.iso file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
      register: rhcosisofile

    - name: Download rhcos iso to cache
      ansible.builtin.get_url:
        url: "https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-live.x86_64.iso"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        mode: '0644'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true
      when: rhcosisofile.stat is defined and not rhcosisofile.stat.exists

    - name: Create cluster directory
      ansible.builtin.file:
        path: "{{ clusters_dir }}/{{ clustername }}"
        state: "directory"
        mode: "0755"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true

    - name: Copy openshift-install.tar.gz to cluster dir
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        dest: "{{ clusters_dir }}/{{ clustername }}/"

    - name: Untar on openshift-install-linux.tar.gz file
      ansible.builtin.unarchive:
        remote_src: true
        src: "{{ clusters_dir }}/{{ clustername }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        dest: "{{ clusters_dir }}/{{ clustername }}"

    - name: Copy rhcos.iso to cluster dir to master
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-master.iso"

    - name: Copy rhcos.iso to cluster dir to worker
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-worker.iso"

    - name: Copy install-config.yaml
      ansible.builtin.template:
        src: install-config.yaml-upi.j2
        dest: "{{ clusters_dir }}/{{ clustername }}/install-config.yaml"
        mode: '0644'

    - name: Run create single-node-ignition-config files
      ansible.builtin.command: "./openshift-install create single-node-ignition-config"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: install
      changed_when: true

    - name: Add bootstrap.ign to rhcos-master.iso
      ansible.builtin.command: "coreos-installer iso ignition embed -fi bootstrap-in-place-for-live-iso.ign rhcos-master.iso"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: rhcosmaster
      changed_when: true

    - name: Add worker.ign to rhcos-worker.iso
      ansible.builtin.command: "coreos-installer iso ignition embed -fi worker.ign rhcos-worker.iso"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: rhcosworker
      changed_when: true

    - name: Create virtual machines disks when SNO
      ansible.builtin.command: "qemu-img create -f qcow2 {{ clustername }}-master-0.qcow2 120G"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: qcow2master
      changed_when: true

    - name: Create worker disks
      ansible.builtin.command: "qemu-img create -f qcow2 {{ clustername }}-worker-{{ item | int + 1 }}.qcow2 120G"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      with_sequence: count={{ n_worker }} start=0
      when: n_worker != 0

    - name: Define KVM VMs when SNO
      ansible.builtin.command: virt-install --import --name {{ clustername }}-master-0   \
            --disk {{ clusters_dir }}/{{ clustername }}/{{ clustername }}-master-0.qcow2,bus=virtio,size=120 \
            --disk {{ clusters_dir }}/{{ clustername }}/rhcos-master.iso,device=cdrom \
            --boot hd,cdrom --check path_in_use=off --noreboot --noautoconsole \
            --ram "{{ master_mem }}" --cpu host --vcpus "{{ master_cpu }}" --os-variant rhel9-unknown --network network={{ kvmnetwork }},model=virtio
      register: createnodes
      become: true
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: createnodes.rc == 0

    - name: Starting virtual machines when SNO
      ansible.builtin.command: "virsh start {{ clustername }}-{{ item }}"
      register: startsnovms
      changed_when: startsnovms.rc == 0
      become: true
      with_items:
        - "master-0"

    - name: Wait for master to get mac address
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-master-0 | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: master_info
      until: master_info is defined and master_info.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true

    - name: Wait for the master VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-master-0 | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: master0ip.stdout is defined and master0ip.stdout != ""
      register: master0ip
      become: true
      changed_when: true

    - name: Create cluster network conf on dnsmasq
      ansible.builtin.template:
        src: "cluster-network.conf.j2"
        dest: "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        mode: '0644'
        selevel: s0
        serole: object_r
        setype: dnsmasq_etc_t
        seuser: system_u
      register: dnsmasq
      become: true

    - name: Create addnhosts file
      ansible.builtin.template:
        src: "dnsmasq.openshift.addnhosts.j2"
        dest: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        mode: '0644'
      register: addnhosts
      become: true

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      when: dnsmasq.changed
      become: true

    - name: Restart libvirt when configuring dnsmasq
      ansible.builtin.service:
        name: libvirtd
        state: restarted
      when: dnsmasq.changed
      become: true

    - name: Adding master mac on DHCP
      community.libvirt.virt_net:
        name: "{{ kvmnetwork }}"
        command: modify
        xml: "<host mac='{{ master_info.stdout_lines | first }}' ip='{{ master0ip.stdout_lines | first }}'/>"
      register: master_info
      become: true

    - name: Define KVM Workers
      ansible.builtin.command: virt-install  --import --name {{ clustername }}-worker-{{ item }}   \
            --disk {{ clusters_dir }}/{{ clustername }}/{{ clustername }}-worker-{{ item }}.qcow2,bus=virtio,size=120 \
            --disk {{ clusters_dir }}/{{ clustername }}/rhcos-worker.iso,device=cdrom \
            --boot hd,cdrom --check path_in_use=off --noautoconsole \
            --ram {{ worker_mem }} --cpu host --vcpus {{ worker_cpu }} --os-variant rhel9-unknown --network network={{ kvmnetwork }},model=virtio \
      register: createworkers
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: createworkers.rc == 0
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Wait for the worker VM's to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-worker-{{ item }} | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: workerip.stdout is defined and workerip.stdout != ""
      register: workerip
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Get a list of all virtual machines
      ansible.builtin.command: virsh list --all --name
      register: vms
      changed_when: vms.rc == 0
      become: true

    #  TODO: fix
    - name: Filter VMs containing 'worker' in their names
      ansible.builtin.set_fact:
        worker_vms: "{{ vms.stdout_lines | select('search', 'worker') }}"
      when: n_worker != 0
      become: true

    - name: Gather MAC addresses of VMs
      ansible.builtin.command: virsh domifaddr {{ item }}
      loop: "{{ worker_vms }}"
      register: vm_interfaces
      changed_when: vm_interfaces.rc == 0
      when: n_worker != 0
      become: true

    - name: Extract MAC addresses from interface information
      ansible.builtin.set_fact:
        mac_addresses: "{{ mac_addresses | default([]) + [item.stdout | regex_findall('([\\w:]{17})')] }}"
        worker_ips: "{{ worker_ips | default([]) + [item.stdout | regex_findall('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}')] }}"
      loop: "{{ vm_interfaces.results }}"
      when: n_worker != 0
      become: true

    - name: Adding worker mac on DHCP
      community.libvirt.virt_net:
        name: "{{ kvmnetwork }}"
        command: modify
        xml: "<host mac='{{ mac_addresses[item | int - 1] | first }}' ip='{{ worker_ips[item | int - 1] | first }}'/>"
      register: worker_info
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Adding worker names on dhcp
      ansible.builtin.lineinfile:
        path: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        line: '{{ worker_ips[item | int - 1] | first }} {{ clustername }}-worker-{{ item }}.{{ basedomain }}'
        state: present
      register: dhcpname
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      when: dhcpname.changed
      become: true

    - name: Restart libvirt when configuring dnsmasq
      ansible.builtin.service:
        name: libvirtd
        state: restarted
      when: dhcpname.changed
      become: true

    - name: Add StrictHostKeyChecking option to SSH config
      ansible.builtin.lineinfile:
        path: "{{ lookup('env', 'HOME') }}/.ssh/config"
        create: true
        mode: '0600'
        line: "StrictHostKeyChecking no"
        state: present
        insertafter: EOF
        owner: "{{ ansible_facts['user_id'] }}"
        group: "{{ ansible_facts['user_id'] }}"

    - name: Sleeping for 20 minutes before to check if cluster has been installed
      ansible.builtin.pause:
        minutes: 20

    - name: Wait for SSH to be available on the target node
      ansible.builtin.wait_for:
        host: "{{ worker_ips[item | int - 1] | first }}"
        port: 22
        timeout: 3600
        state: started
        sleep: 10
      with_sequence: count={{ n_worker }}

    - name: Copy worker.ign to worker nodes
      ansible.builtin.copy:
        src: "{{ clusters_dir }}/{{ clustername }}/worker.ign"
        dest: "/var/home/core/worker.ign"
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      when: n_worker != 0

    - name: Excute coreos-installer on worker nodes
      ansible.builtin.shell:
        cmd: "coreos-installer install --ignition-file=/var/home/core/worker.ign /dev/vda"
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      become: true
      when: n_worker != 0

    - name: Rebooting worker nodes
      ansible.builtin.reboot:
        reboot_timeout: 300
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      become: true
      when: n_worker != 0

    #  TODO: retry if error and not only ignore
    - name: Creating CSR Approver manifests
      kubernetes.core.k8s:
        kubeconfig: "{{ clusters_dir }}/{{ clustername }}/auth/kubeconfig"
        state: present
        template: "{{ item }}.yaml.j2"
      loop:
        - csr-approver-ns
        - csr-approver-sa
        - csr-approver-cr
        - csr-approver-crb
        - csr-approver-rb
        - csr-approver-cronjob
      ignore_errors: true
      when: n_worker != 0

    - name: Run wait-for install-complete
      ansible.builtin.command: "./openshift-install wait-for install-complete"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      async: 3600
      poll: 0
      register: install
      changed_when: true

    - name: Check if the cluster has been installed
      ansible.builtin.async_status:
        jid: "{{ install.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      delay: 10
      retries: 600

    # - name: Pause cronjob ocp-csr-approver
    #   kubernetes.core.k8s:
    #     kubeconfig: "{{ clusters_dir }}/{{ clustername }}/auth/kubeconfig"
    #     state: present
    #     definition:
    #       apiVersion: batch/v1
    #       kind: CronJob
    #       metadata:
    #         name: "ocp-csr-approver"
    #         namespace: "ocp-csr-approver"
    #       spec:
    #         suspend: true
